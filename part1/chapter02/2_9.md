# 비교 연산자

### 문자열 비교

자바스크립트는 문자열을 **'사전 순'** 으로 비교한다. 사전편집(lexicographical)순으로 불리기도 하는 이 기준을 적용하면 **사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단된다.**

실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다.

```javascript
    alert( 'Z' > 'A' ); // true
    alert( 'Glow' > 'Glee' ); // true
    alert( 'Bee' > 'Be' ); // true
```
**적용되는 알고리즘**
1. 두 문자열의 첫 글자를 비교한다.
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글짜보다 크면, 첫 번째 문자열이 두 번째 문자열보다 크다고 결론내고 비교를 종료한다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교
4. 글자간 비교가 끝날 때까지 이 과정을 반복한다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 낸다. 비교가 종료 되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.

### 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트든 이 값들을 **숫자형**으로 바꾼다.

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```

### 흥미로운 상황

다음의 상황을 살펴보자.

- 동등 비교(==) 시 true를 반환함
- 논리 평가 시 값 하나는 true, 다른 값 하나는 false를 반환함

이럴수가 있을까? 놀랍게도 자바스크립트에서는 가능하다.

```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

두 값(a와 b)을 비교하면 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 참, 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있다.

그런데 자바스크립트 관점에선 이런 결과가 아주 자연스럽다.

동등 비교 연산자 ==는 (예시에서 문자열 "0"을 숫자 0으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문이다.

### 일치 연산자

동등 연산자(equality operator) ==은 0과 false를 구별하지 못한다.

```javascript
alert( 0 == false ); // true
alert( '' == false ); // true
```
그럼 어떻게 구별할까?

**일치 연산자(strict equality operator) ===를 사용하면 형 변환 없이 값을 비교할 수 있다.**

일치 연산자는 **엄격한(strict) 동등 연산자**이다. 자료형의 동등 여부까지 검사하기 때문에 피연산자 a와 b의 형이 다를 경우 `a === b`는 즉시 false를 반환한다.

### null이나 undefined와 비교하기

1. 일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교

    두 값의 자료형이 다르기 때문에 거짓을 반환.

    `alert( null === undefined ); // false`

2. 동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교

    `alert( null == undefined ); // true`

동등 연산자를 사용해 비교하면 특별한 규칙이 적용돼 `true`가 반환된다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플' 취급한다.

3. 산술 연산자나 기타 비교 연산자 <, >, <=, >=를 사용하여 null과 undefined를 비교


null과 undefined는 숫자형으로 변환된다. null은 0, undefined는 NaN으로 변한다.

### null vs 0

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위 비교 결과는 논리에 맞지 않아 보인다. (3)에서 null은 0보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있다.

이런 결과가 나타나는 이유는 **동등 연산자 ==와 기타 비교 연산자 <, >, <=, >=의 동작 방식이 다르기 때문이다.**

(1)에서 null > 0이 거짓을, (3)에서 null >= 0이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) **null이 숫자형으로 변환돼 0이 되기 때문이다.**

그런데 동등 연산자 ==는 피연산자가 undefined나 null일 때 형 변환을 하지 않는다. undefined와 null을 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환한다. 이런 이유 때문에 (2)는 거짓을 반환한다.

### 비교가 불가능한 undefined

undefined를 다른 값과 비교해서는 안된다.

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

- (1)과(2)에선 undefined가 NaN으로 변환되는데(숫자형으로의 변환), NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환한다.
- undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환한다.

### 함정 피하기

> 위와 같은 에지 케이스를 왜 살펴보았을까요? 이런 예외적인 경우를 꼭 기억해 놓고 있어야만 할까요? 그렇지는 않습니다. 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해지기 때문에 지금 당장 암기해야 할 필요는 없습니다. 하지만 아래와 같은 방법을 사용해 이런 예외 상황을 미리 예방할 수 있다는 점은 알아두시길 바랍니다.

- 일치 연산자 ===를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의하라.

- 또한, undefined나 null이 될 가능성이 있는 변수가 <, >, <=, >=의 피연산자가 되지 않도록 주의하라. (명확한 의도를 갖고 있지 않은 이상) 만약 변수가 undefined나 null이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가해라.